{"meta":{"title":"张有亮|个人博客","subtitle":null,"description":null,"author":"Zhangyouliang","url":"https://www.whatdy.com"},"pages":[{"title":"张有亮","date":"2018-03-19T15:54:20.000Z","updated":"2018-03-20T16:47:46.000Z","comments":true,"path":"about/index.html","permalink":"https://www.whatdy.com/about/index.html","excerpt":"","text":"生于1995年,山东临沂人,目前工作地点在上海,从事业务开发和基础架构研发工作。 目前是一名 PHPER,但是自己同时非常喜欢 Python 和 Java 相关编程,对网络安全方面非常感兴趣。对如今主流互联网基础均有不同程度的掌握,尤其擅长后端方面,擅长运维方面的技术,平时喜欢逛各大博客,论坛,github等开源社区。 除了 coding 之外,还有以下爱好: 看动漫(b站),看直播 手机游戏 喜欢吃(虽然记不得吃的啥,但是可以记住味道)"},{"title":"标签","date":"2018-03-19T15:55:43.000Z","updated":"2018-03-21T13:29:03.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.whatdy.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"各种实用的东东","slug":"各种实用的东东","date":"2018-04-05T16:25:01.000Z","updated":"2018-04-05T16:25:55.288Z","comments":true,"path":"2018/04/06/各种实用的东东/","link":"","permalink":"https://www.whatdy.com/2018/04/06/各种实用的东东/","excerpt":"","text":"PHP Slim - PHP微框架，简单易用易拓展。 Swoole - Swoole是一个PHP的C扩展，可用来开发PHP的高性能高并发TCP/UDP Server。 Guzzle - 强大的RESTful 客户端，支持批量请求。 PHP Super Closure - 解决PHP不支持序列化(serialize) Closure 问题。 PHP Selector - 像jquery选择器一样操作操作网页DOM, 支持大部分CSS3选择器。 Simple Yet Powerful PHP Caching Class - 好用的PHP缓存类,支持：Files, MemCache, MemCached, APC, WinCache, X-Cache, PDO with SQLite。 Zephir - Zephir是一种高级编译语言,为简单编写PHP的C扩展而生。 Laravel Push Notification - Laravel 推送工具。 Intervention Image - 一个PHP图像处理和操作库，提供更简单和表达方式来创建，编辑和构图。该软件还包括提供服务提供器(ServiceProviders)和外观(Facades)，方便Laravel整合。 Sami - PHP API文档生成工具，生成代码注释文档。 overtrue/socialite PHP 通用第三方登录组件，支持：微博、QQ、微信公众平台，微信开放平台、豆瓣，Facebook、Google、GitHub、Linkedin。 overtrue/pinyin 史上最准确的PHP中文转拼音工具 overtrue/wechat 目前最好用的微信开发工具包 overtrue/package-builder Composer 包构建工具 Laravel laravel-shopping-cart - Laravel 购物车，简单方便,文档齐全。 laravel-lang - Laravel 语言包，支持 44+ 种语言。 Laravel-MongoDB - Laravel 的 MongoDB 数据库组件 laravel-pinyin - Laravel 的中文转拼音插件，基于overtrue/pinyin laravel-wechat - Laravel 的微信开发组件，基于overtrue/wechat Javascript phpjs - PHP函数的js实现。 string.js - 轻量级(&lt;5kb)的JavaScript字符串操作库，强大的字符串处理API。 underscore - 强大的js函数库，提供超多易用的封装。 readmore.js - 隐藏过长的文章。按高度隐藏的，如果担心Feed流里边因为某篇文章特别长，影响浏览时可以用上。支持bower，install readmore 即可。 share.js - 一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等社交网站。 Unslider - 简单易用的jQuery slider 插件。 SideComments.js - 类似Medium.com的文本边栏评论插件。 Github.js - GitHub API js版本。 Moment.js - 提供在JavaScript中分析，验证，操作和显示日期的API。 cheerio - 专为服务器端设计的，快速，灵活，精益的jQuery核心功能实现。 marked - 一个高效的Markdown分析器和编译器。 markdown-js - JavaScript Mardown 解析器。 Spin.js - “加载中” 动画生成工具。 emojify.js - 超简单的让你的网页支持emoji表情。 highlightjs - 代码高亮。 fengyuanchen/distpicker - 中国省市区三级联动，强大的自定义功能。 表单美化 switchery - IOS7风格的checkbox美化插件，demo: http://abpetkov.github.io/switchery/。 chosen - 下拉框美化强化插件，demo: http://harvesthq.github.io/chosen/。 formatter.js - 强大输入框格式化插件，指定输入框可输入的格式。 iCheck - 高度可定制的复选框和单选按钮 (jQuery &amp; Zepto)。 框架 ionic - 混合应用开发框架，使用html+javascript+css创建Android与IOS应用。 CSS typo.css - 中文网页重设与排版，一致化浏览器排版效果，构建最适合中文阅读的网页排版。 规范 开源项目目录规范 JavaScript编码规范 CSS 编码规范 HTML 编码规范 Markdown 编写规范 图标 ionicons - ionic图标。 emoji查询,emoji-cheat-sheet - emoji查询。 emojify.js - 让你的网页支持emoji表情。 前端工具 FIS - Front-end Integrated Solution - 前端集成解决方案。 JavaScript的远程Web控制台 - Console.IO是一个NodeJS项目。它为网站和Web应用程序提供的远程Web控制台。它采用express.io（express和socket.io）提供用户实时体验。 它能工作在几乎所有的现代浏览器，移动设备，智能电视等平台。 CSS3动画生成工具 - 在线制作&amp;预览CSS3动画。 服务器 H2O - 比nginx快2倍的web服务器。 Atlas - 基于MySQL协议的数据库中间层项目。 工具类 StackEdit - 强大的在线Markdown编辑器，在线地址：https://stackedit.io/。 Spacegray - 特别漂亮的Sublime Text主题，建议与Monaco字体配合使用。 Colorsublime - 超多Sublime Text主题。 Sublime text 插件 Alignment - 代码对齐工具，根据=号对齐以及其它定义的符号竖向对齐你的代码。 EncodingHelper - 在状态栏显示当前文件的编码，支持从其它编码转为UTF-8。 SideBarEnhancement - 边栏菜单增强工具。 Tag - html标签助手。 All Autocomplete - 在当前打开的文件中提示函数，方法名等。 DocBlockr - 自动注释工具。 Pretty JSON - json格式化工具，快捷键：OSX: cmd+ctl+j, win: ctl+alt+j。 ColorPicker - 直接在sublime里调用调色板的工具。 Emmet - 高效编写HTML的工具，原zen-coding。 AutoFileName - 自动完成路径的文件 - 非常方便。 Git - 顾名思义。 GitGutter - 在边栏高亮你的文件内容变动，增加，删除，修改，类似git diff一样的效果。 Modific - 与上一个插件基本一样。 Sublimall - 免费的Sublime备份与同步工具，只需要一个账户，你的插件，配置，打开的文件等都会自动同步。 MarkdownEditing - Markdown编写的最好插件：语法高亮，缩写，自动完成，配色方案等 Sublime SFTP - SFTP工具。 CTags - 自动提示工具。 SublimeLinter - 语法检测工具，支持： C/C++, Java, Python, PHP, JS, HTML, CSS等。 CSScomb - CSS编码风格格式化工具。 FixMyJS, Jsfmt 与 JsFormat - Js/JSON编码风格格式化工具 AStyleFormatter - C/C++/C#/Java 编码风格格式化工具 SVG-Snippets - 设置自定义SVG片段。 Inc-Dec-Value - 数字，日期，十六进制颜色值等的递增/递减. 书籍与教程 《The Swift Programming Language》 - 中文版 Apple 官方 Swift 教程。 《程序员编程艺术 — 面试和算法心得》 - CSDN 600万博客结构之法算法之道部分经典博文优化版。 RESTful API 接口设计指北 - 不错的API设计教程。 GitHub秘籍 - GitHub秘籍 解决方案 icomet - 一个支持百万并发连接的comet服务器：icomet。 node-webkit -基于chromium和nodejs的应用，允许你使用html+javascript开发桌面应用。 pdf2htmlEX - 转换PDF为Html。 highlightjs - 代码高亮。 ## 参考:http://overtrue.me/articles/2014/10/bookmarks.html","categories":[{"name":"php","slug":"php","permalink":"https://www.whatdy.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.whatdy.com/tags/php/"}]},{"title":"nginx 重写规则","slug":"nginx-重写规则","date":"2018-04-05T09:25:35.000Z","updated":"2018-04-05T09:27:41.494Z","comments":true,"path":"2018/04/05/nginx-重写规则/","link":"","permalink":"https://www.whatdy.com/2018/04/05/nginx-重写规则/","excerpt":"","text":"nginx rewrite 指令执行顺序 # rewrite 执行server块的rewrite指令(这里的块指的是server关键字后{}包围的区域) 执行 location 匹配 执行选定的location中的rewrite指令 如果其中某步URI被重写,则重新循环执行1~3,直到找到真正的文件.如果循环超过10次,则出现500 Internal Server Error 错误 flag 标志位: 1rewrite regex URL [flag]; rewrite 是关键字，regex 是正则表达式，URL是要替代的内容，[flag]是标记位的意思，它有以下几种值： last: 相当于Apache的[L]标记，表示完成rewrite break: 停止执行当前虚拟主机的后续rewrite指令集 redirect: 返回302临时重定向，地址栏会显示跳转后的地址 permanent: 返回301永久重定向，地址栏会显示跳转后的地址 # location的用法location ~* /js/.*/\\.js以 = 开头，表示精确匹配；如只匹配根目录结尾的请求，后面不能带任何字符串。以^~ 开头，表示uri以某个常规字符串开头，不是正则匹配以~ 开头，表示区分大小写的正则匹配;以~* 开头，表示不区分大小写的正则匹配以/ 开头，通用匹配, 如果没有其它匹配,任何请求都会匹配到 123456location / &#123; # Redirect everything that isn&apos;t a real file to index.php try_files $uri $uri/ /index.php$is_args$args; &lt;==&gt; try_files $uri $uri/ /index.php?$query_string;&#125;# 或者 rewrite ^/(.*)$ /index.php/$1 last; 优先级: (location = 精准匹配) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 例子: 1234567891011121314151617# 这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;# 第三个规则就是通用规则，用来转发动态请求到后端应用服务器location / &#123; proxy_pass http://tomcat:8080/&#125; # if 判断指令当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false直接比较变量和内容时，使用=或!=~ 正则表达式匹配~* 不区分大小写的匹配!~ 区分大小写的不匹配-f和!-f 用来判断是否存在文件-d和!-d 用来判断是否存在目录-e和!-e 用来判断是否存在文件或目录-x和!-x 用来判断文件是否可执行 123456789101112131415161718192021222324if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break;&#125; //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123; set $id $1; &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分if ($request_method = POST) &#123; return 405;&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302if ($slow) &#123; limit_rate 10k;&#125; //限速，$slow可以通过 set 指令设置if (!-f $request_filename)&#123; break; proxy_pass http://127.0.0.1; &#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查if ($args ~ post=140)&#123; rewrite ^ http://mysite.com/ permanent;&#125; //如果query string中包含&quot;post=140&quot;，永久重定向到mysite.com if指令中，可以使用全局变量，这些变量有：$args： #这个变量等于请求行中的参数，同$query_string$content_length： 请求头中的Content-length字段。$content_type： 请求头中的Content-Type字段。$document_root： 当前请求在root指令中指定的值。$host： 请求主机头字段，否则为服务器名称。$http_user_agent： 客户端agent信息$http_cookie： 客户端cookie信息$limit_rate： 这个变量可以限制连接速率。$request_method： 客户端请求的动作，通常为GET或POST。$remote_addr： 客户端的IP地址。$remote_port： 客户端的端口。$remote_user： 已经经过Auth Basic Module验证的用户名。$request_filename： 当前请求的文件路径，由root或alias指令与URI请求生成。$scheme： HTTP协议（如http，https）。$server_protocol： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr： 服务器地址，在完成一次系统调用后可以确定这个值。$server_name： 服务器名称。$server_port： 请求到达服务器的端口号。$request_uri： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri： 与$uri相同。$query_string： 请求参数,不写GET会接收不到参数(get 参数丢失往往都是因为他)。$is_args 如果$args设置，值为”?”，否则为””。$uri 请求中的当前URI(不带请求参数，参数位于$args)$args 这个变量等于GET请求中的参数。例如，foo=123&amp;bar=blahblah;这个变量只可以被修改","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.whatdy.com/tags/nginx/"}]},{"title":"git 常用命令","slug":"git-常用命令","date":"2018-03-31T13:34:40.000Z","updated":"2018-04-02T10:07:06.802Z","comments":true,"path":"2018/03/31/git-常用命令/","link":"","permalink":"https://www.whatdy.com/2018/03/31/git-常用命令/","excerpt":"","text":"# tag1234567git tag 显示已经有的标签git tag -l &apos;v1.0.*&apos; 匹配标签git tag -a v1.0.0 -m &apos;connotated&apos; 含附注的标签git tag v1.0.0 创建轻量标签git show v1.0.0 查看标签git push origin v1.0.0 标签分享git push origin --tags 分享全部标签 # git ls-remote查看远程仓库情况12git ls-remote --tags 查看远程tag情况git ls-remote --get-url 查看远程 url # cherry-pick1git cherry-pick &lt;commit id&gt; 提交单个commit 到当前分支 # git fetch , git rebase,git pull1234git fetch 从远程拉去信息到本地仓库git pull 从远程拉去信息到本地仓库和工作区域git fetch origin master 拉去 origin 上面的 master 分支信息(--all 拉去全部远程仓库数据)git rebase origin/master 合并 origin/master 到本地工作区 # clean1git checkout . &amp;&amp; git clean -xdf 删除当前全部没有提交的数据 # checkout12git checkout -b feature-1 origin/master 根据远程分支的基础上分化出一个新的分支来git checkout &lt;file&gt; 从暂存区恢复文件 # push **1git push [远程名] :[分支名] # git push origin :serverfix 删除远程分支名,但是保留本地 commit,git push [远程名] [本地分支]:[远程分支] 语法，如果省略[本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。 # rm12git rm --cached &lt;file&gt; 解除对改文件的 trackedgit reset HEAD &lt;file&gt; 从暂存区删除该文件 # stash注意只能暂存添加到 stage 当中的数据1234git stash 可用来暂存当前正在进行的工作git stash pop 取出,并且删除最后一次 stash 的数据git stash save &quot;work in progress for foo feature&quot; 添加注释git stash list 查看 stash 列表 # git 相关别名1234567alias.st=statusalias.co=checkoutalias.ci=commitalias.br=branchalias.lg=log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commitalias.unstage=reset HEADalias.last=log -1 # rebase , merge12345678910111213141516171819202122232425262728 o---o---o---o---o master \\ o---o---o---o---o next \\ o---o---o topic# 将 topic 与 next 不同部分 衍合到 master 分支当中,注意不衍合 topic 和next 共有部分!!! (这里功能是合并topic 特有的三个 commit )# git rebase --onto master next topic# git merge topic # on master branch o---o---o---o---o master | \\ | o&apos;--o&apos;--o&apos; topic \\ o---o---o---o---o next# 测试完毕 next 分支,再把 next 分支衍合git rebase master next # git merge next # on master branch# 上面提到的,如果我们打算将 topic 分支与 master 合并,可以使用下面两个命令# on master branch git merge topic git rebase topic # git rebase 多人开发123456789101112131415161718# dev# git pull ==&gt; git fech origin master &amp;&amp; git merge origin/master# git rebase origin master 我在本地的分支 dev_branch上， 对远程仓库（默认origin代表远程仓库）的 master 使用变基拣选操作# git rebase master 对本地仓库的master使用变基拣选操作git pull --rebase origin mastergit co master &amp;&amp; git merge dev &amp;&amp; git push# momo# git pull = git fetch + git merge# git pull --rebase = git fetch + git rebasegit pull --rebase origin mastergit checkout master &amp;&amp; git merge momo &amp;&amp; git push","categories":[{"name":"git","slug":"git","permalink":"https://www.whatdy.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.whatdy.com/tags/git/"}]},{"title":"docker+supervisor 实现后台运行程序","slug":"docker-supervisor-实现后台运行程序","date":"2018-03-31T06:50:51.000Z","updated":"2018-03-31T07:00:12.101Z","comments":true,"path":"2018/03/31/docker-supervisor-实现后台运行程序/","link":"","permalink":"https://www.whatdy.com/2018/03/31/docker-supervisor-实现后台运行程序/","excerpt":"","text":"注意 supervisor 不支持任何的 python3 基础镜像构建Dockerfile1234567891011FROM python:3.6.3WORKDIR /appCOPY requirements.txt /app# 由于本身代码是 py3的,所以这里另外安装一个 py2 RUN pip install --trusted-host pypi.python.org -r requirements.txt \\ &amp;&amp; pip install virtualenv \\ &amp;&amp; virtualenv --system-site-packages -p python2.7 /opt/python2.7 \\ &amp;&amp; /opt/python2.7/bin/pip install supervisor \\ &amp;&amp; /opt/python2.7/bin/echo_supervisord_conf &gt; /etc/supervisord.conf requirements.txt123456APScheduler==3.5.1configparser==3.5.0DBUtils==1.2PyMySQL==0.8.0requests==2.18.4... 其他的包 镜像构建: docker build -t test:latest . 文件目录结构:12345678.├── Dockerfile├── app.py├── docker│ ├── config.sh│ ├── start.sh│ └── supervisor│ └── cron.conf 这里其实我是为了启动 app.py 文件的 123456789101112131415161718192021222324252627282930313233343536# start.sh#!/bin/bash#根据环境变量启动镜像/docker/config.sh#启动守护/opt/python2.7/bin/supervisord -c /etc/supervisord.conf# config.sh#!/bin/bashsed -i -e &quot;s/nodaemon=false/nodaemon=true /g&quot; /etc/supervisord.confsed -i -e &quot;s/;\\[include\\]/\\[include\\]/g&quot; /etc/supervisord.confecho &apos;files=/docker/supervisor/*.conf&apos; &gt;&gt; /etc/supervisord.conf# cron.conf[program:cron]command=/usr/local/bin/python /app/app.pyautorestart=truestdout_events_enabled=truestderr_events_enabled=true# DockerfileFROM test:latestMAINTAINER YouliangZhang &lt;1577121881@qq.com&gt;# ------------------------------------------------------------------------------# Provision the server# ------------------------------------------------------------------------------RUN mkdir /dockerADD docker /dockerADD . /appRUN chmod a+x /docker/*.sh# Use Supervisor to run and manage all other servicesCMD [&quot;/docker/start.sh&quot;] 镜像构建: docker build -t xx:latest .镜像启动: docker run -d xx:latest --name xx","categories":[{"name":"docker","slug":"docker","permalink":"https://www.whatdy.com/categories/docker/"},{"name":"python","slug":"docker/python","permalink":"https://www.whatdy.com/categories/docker/python/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.whatdy.com/tags/docker/"},{"name":"python","slug":"python","permalink":"https://www.whatdy.com/tags/python/"}]},{"title":"python 实用技巧","slug":"python-实用技巧","date":"2018-03-31T06:33:19.000Z","updated":"2018-03-31T06:34:05.670Z","comments":true,"path":"2018/03/31/python-实用技巧/","link":"","permalink":"https://www.whatdy.com/2018/03/31/python-实用技巧/","excerpt":"","text":"# dict 合并 update() d3 = dict(d1.**d2)","categories":[{"name":"python","slug":"python","permalink":"https://www.whatdy.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.whatdy.com/tags/python/"}]},{"title":"linux 实用命令","slug":"linux-实用命令","date":"2018-03-31T06:30:01.000Z","updated":"2018-03-31T06:38:41.880Z","comments":true,"path":"2018/03/31/linux-实用命令/","link":"","permalink":"https://www.whatdy.com/2018/03/31/linux-实用命令/","excerpt":"","text":"# sed比如，我想替换文件中的 properties 为 property ,可以使用1sed 's/properties/property/g' build.xml 这种方式，其实并没有修改build.xml文件的内容。如果想保存修改，通常的做法就需要重定向到另外的一个文件 123sed 's/properties/property/g' build.xml &gt; build.xml.tmp# 如果想直接修改源文件，而没有这样的过程，可以用下面的命令sed -i 's/properties/property/g' build.xml # 列出当前目录全部的目录1234# 三种方式find . -type d -maxdepth 1ls -F | grep '/$'ls -l | grep '^d' # 列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归12ls | sed \"s:^:`pwd`/:\"find $PWD -maxdepth 1 | xargs ls -ld # nl显示文件的行数 # head显示前几行 # sort按照顺序排序 # watch每隔一秒高亮显示网络链接数的变化情况 watch -n 1 -d netstat -ant 每隔一秒高亮显示http链接数的变化情况 watch -n 1 -d ‘pstree|grep http’ cat查看文件并且显示行数cat -n /etc/inetd.conf # tee把数据重定向到给定文件和屏幕上 12# 将 ls 的 stdin 重定向到文件,并且输出到屏幕上面ls | tee out.txt # wget参考 1234567-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-c：继续执行上次终端的任务；-O filename 将文件保存为 filename-i&lt;文件&gt;：从指定文件获取要下载的URL地址；--limit-rate=300k 限速下载-c 断点续传--user-agent 伪装代理名称下载 # find参考12345678atime n 查找系统中最后N分钟访问的文件amin n 查找系统中最后n*24小时访问的文件# 查找今天的(24小时内)find . -atime -1# 查找今天之前的(24小时内)find . -atime +1# 搜索当前目录的以 .log 结尾,一天内,权限问 600 ,大小大于 1 b 的普通文件,并且按照普通方式输出find . -type f -name &apos;*.log&apos; -atime -1 -perm 600 -size +1c -print # xargsxargs 命令是一个其他命令参数传递一个过滤器,擅长将stdin转化成命令参数,xargs 能够处理管道或者 stdin 并将其转化成特定命令的命令参数. xargs 的默认命令是echo ,空格是默认定界符.这也就意味着通过管道传递给xargs包含换行和空白,不过通过xargs的处理,换行和空白将被空格取代 cat abc | xargs echo &lt;=====&gt; cat abc | xargs 测试文件:1234567891011121314➜ ~ cat abc | xargs a b c d e f g h i j k l m n o p q r s t u v w x y z➜ ~ cat abc | xargs -n3a b cd e fg h ij k lm n op q rs t uv w xy z➜ ~ echo &quot;nameXnameXnameXname&quot; | xargs -dXname name name name 读取 stdin,将格式化后的参数传递给命令 1234➜ ~ cat sk.sh #!/bin/shecho $* 测试12345678➜ ~ cat arg aaabbbccc➜ ~ cat arg | xargs -I &#123;&#125; ./sk.sh &#123;&#125;aaabbbccc xargs 的一个选项 -I , 使用 -I 指定一个替换字符串{},这个字符串在xargs拓展时会被替换掉,每一个参数命令都会被执行一次： 123456➜ ~ cat abc | xargs -I &#123;&#125; ./sk.sh &quot;==&gt;&quot; &#123;&#125; &quot;&lt;==&quot;==&gt; a b c d e f g &lt;====&gt; h i j k l m n &lt;====&gt; o p q &lt;====&gt; r s t &lt;====&gt; u v w x y z &lt;== xargs 结合 find 使用 用rm 删除太多的文件时候，可能得到一个错误信息：/bin/rm Argument list too long. 用xargs去避免这个问题 xargs -0 将\\0作为定界符统计一个源代码目录中所有php 文件的行数 123456789101112131415161718192021## 正常输出➜ Controllers git:(master) find . -type f -name &apos;*.php&apos; -print./Controller.php./FetchController.php./LoginController.php./SockController.php./TestController.php## 将 \\n 替换为 NULL➜ Controllers git:(master) find . -type f -name &apos;*.php&apos; -print0./Controller.php./FetchController.php./LoginController.php./SockController.php./TestController.php## 将 find 中的数据的 \\n 替换为 NULL,同时 xargs 将 NULL 作为定界符➜ Controllers git:(master) find . -type f -name &apos;*.php&apos; -print0 | xargs -0 wc -l 71 ./Controller.php 95 ./FetchController.php 54 ./LoginController.php 112 ./SockController.php 30 ./TestController.php 362 total 查找所有 jpg 文件,并且压缩他们 1find . -type f -name &apos;*.jpg&apos; -print | xargs tar -czvf images.tar.gz 下载1cat url-list.txt | xargs wget -c","categories":[{"name":"LINUX","slug":"LINUX","permalink":"https://www.whatdy.com/categories/LINUX/"}],"tags":[{"name":"LINUX","slug":"LINUX","permalink":"https://www.whatdy.com/tags/LINUX/"}]},{"title":"docker CMD 和 ENTRYPOINT","slug":"docker-CMD-和-ENTRYPOINT","date":"2018-03-31T06:27:04.000Z","updated":"2018-03-31T06:28:23.273Z","comments":true,"path":"2018/03/31/docker-CMD-和-ENTRYPOINT/","link":"","permalink":"https://www.whatdy.com/2018/03/31/docker-CMD-和-ENTRYPOINT/","excerpt":"","text":"CMD支持三种形式: CMD [“executable”,”param1”,”param2”] 使用 exec 执行，推荐方式；123456789FROM python:3.6.3CMD [\"python\"]# docker run --rm -it test 不要带执行命令➜ test docker run --rm -it test Python 3.6.3 (default, Dec 12 2017, 16:40:53) [GCC 4.9.2] on linuxType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; 相当于/bin/sh -c python CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用； CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数； 12345678FROM python:3.6.3CMD \"python\"# CMD 部分展现\"Cmd\": [ \"/bin/sh\", \"-c\", \"\\\"python\\\"\"], 123456789FROM python:3.6.3CMD /usr/local/bin/python# CMD 部分展现\"Cmd\": [ \"/bin/sh\", \"-c\", \"/usr/local/bin/python\"], 1234567FROM python:3.6.3CMD [\"python\"]# CMD 部分展现\"Cmd\": [ \"python\"], 总结如下: CMD shell 形式并且为参数的时候,会传递给 sh,形式为 /bin/sh -c &quot;xxx&quot;CMD shell 形式并且是可执行参数的时候,会传递给 sh,形式为 /bin/sh -c xxx CMD 以可执行命令的方式传入,则会替换 sh,将传入的命令作为基础命令 ,但是会被 run 传入的参数覆盖 例如上面的 python,如果运行 docker run --rm -it test --help,我们的本意是查看python的帮助信息,但是会报错,命令被覆盖为了--help,这个命令是不存在,所以我们可以这样运行docker run --rm -it test python --help 这里还需要注意,由于没有 entrypoint,也就是没有 /bin/sh -c的加持,如果传入字符串会报错,也就是docker run --rm -it test &quot;python --help&quot;,除非设置了一下操作1234567891011FROM python:3.6.3Entrypoint [\"/bin/sh\",\"-c\"]# 1. docker run --rm -it test \"python --help\"# 相当于: /bin/sh -c \"python --help\"# 2. docker run --rm -it test python --help# 相当于: /bin/sh -c python Python 2.7.12 (default, Dec 4 2017, 14:50:18) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; 指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。 如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。 ENTRYPOINT两种格式： ENTRYPOINT [“executable”, “param1”, “param2”] 1234567FROM python3.6.3ENTRYPOINT [\"/usr/local/bin/python\"]# docker inspect &lt;name&gt; 查看明细\"Entrypoint\": [ \"/usr/local/bin/python\"], ENTRYPOINT command param1 param2（shell中执行）。 12345678910FROM python3.6.3ENTRYPOINT \"/usr/local/bin/python\"# docker inspect &lt;name&gt; 查看明细\"Entrypoint\": [ \"/bin/sh\", \"-c\", \"\\\"/usr/local/bin/python\\\"\"], 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。 从上面的说明，我们可以看到有两个共同点： 都可以指定shell或exec函数调用的方式执行命令； 当存在多个CMD指令或ENTRYPOINT指令时，只有最后一个生效；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.whatdy.com/tags/docker/"}]},{"title":"php 相关注意","slug":"php-相关注意","date":"2018-03-26T12:19:02.000Z","updated":"2018-03-26T12:21:50.000Z","comments":true,"path":"2018/03/26/php-相关注意/","link":"","permalink":"https://www.whatdy.com/2018/03/26/php-相关注意/","excerpt":"","text":"$_SERVER 参数123456# 最后一层代理的 IP 地址[REMOTE_ADDR] =&gt; 10.42.149.196# 访问者真实 IP[HTTP_X_FORWARDED_FOR] =&gt; 101.81.14.6# 服务器地址[SERVER_ADDR] =&gt; 10.42.93.182","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.whatdy.com/tags/php/"}]},{"title":"SpringBoot 热部署","slug":"SpringBoot-热部署","date":"2018-03-25T10:35:26.000Z","updated":"2018-03-25T10:35:52.000Z","comments":true,"path":"2018/03/25/SpringBoot-热部署/","link":"","permalink":"https://www.whatdy.com/2018/03/25/SpringBoot-热部署/","excerpt":"","text":"SpringBoot 热部署 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后设置idea Build Execution &gt; Compiler &gt; Build Project automatically 打上勾 Register 设置 : Ctrl + Option + Command 点击 Register ,找到 compiler.automake.allow.when.app.running 重启 IDEA","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.whatdy.com/tags/java/"}]},{"title":"MyBatis 一些问题","slug":"MyBatis-一些问题","date":"2018-03-25T03:50:22.000Z","updated":"2018-03-25T10:04:16.000Z","comments":true,"path":"2018/03/25/MyBatis-一些问题/","link":"","permalink":"https://www.whatdy.com/2018/03/25/MyBatis-一些问题/","excerpt":"","text":"#{}防止SQL注入,动态解析的时候,会解析成参数标记符,类似于:12select * from user name = #&#123;name&#125;;select * from user where name =?; ${}在解析的时候会将我们传入的值当做 String 填充到我们的语句中12select * from user where name = \"admin\";select * from user where name = $&#123;name&#125;; 这是 #{} 和 ${} 我们能看到的主要的区别，除此之外，还有以下区别: #方式能够很大程度防止sql注入。$方式无法防止Sql注入。$方式一般用于传入数据库对象，例如传入表名.一般能用#的就别用$. mybatis 还需要注意: 12345678## 使用 @Param 注解时,参数不仅有 JavaBean,而且还存在 queryObject 这个对象@Select(\"SELECT * from City where id = #&#123;id&#125;\")List&lt;City&gt; getListByCriteria(@Param(\"queryObject\") int id);## 不使用 @Param 注解时,参数只能有一个(JavaBean)@Select(\"SELECT * from City where id = $&#123;id&#125;\")List&lt;City&gt; getListByCriteria(int id); # selectKey使用Oracle的序列、mysql的函数生成ID 方式不一样,这里他们可以通过 selectKey 这个标签获取到插入数据生成的 ID 下面例子，使用mysql数据库 LAST_INSERT_ID() 用来生成一个key，并把他设置到传入的实体类中的 id 属性上。所以在执行完此方法后，边可以通过这个实体类获取生成的key。123456789101112131415161718192021&lt;insert id=\"insert\" parameterType=\"com.whatdy.model.City\" keyProperty=\"id\"&gt;&lt;selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\"&gt; SELECT LAST_INSERT_ID() AS id&lt;/selectKey&gt;insert into city (&lt;trim suffixOverrides=\",\"&gt; id, name, state, country,&lt;/trim&gt;)values (&lt;trim suffixOverrides=\",\"&gt; #&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;state,jdbcType=VARCHAR&#125;, #&#123;country,jdbcType=VARCHAR&#125;,&lt;/trim&gt;)&lt;/insert&gt; 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class CityService &#123; public void testInsert() &#123; City city = new City(); city.setName(\"北京\"); city.setState(\"100001\"); city.setCountry(\"中国\"); int i = cityMapper.insert(city); LOGGER.info(\"insert sql result ======&gt; \"); System.out.println(city.getId()); &#125;&#125; 属性 描述 取值 keyProperty selectKey 语句生成结果需要设置的属性。 resultType 生成结果类型，MyBatis 允许使用基本的数据类型，包括String 、int类型。 order 1：BEFORE，会先选择主键，然后设置keyProperty，再执行insert语句； 2：AFTER，就先运行insert 语句再运行selectKey 语句。 BEFORE AFTER statementType MyBatis 支持STATEMENT，PREPARED和CALLABLE 的语句形式， 对应Statement ，PreparedStatement 和CallableStatement 响应 STATEMENT ,PREPARED,CALLABLE 其他方式获取插入操作返回的主键 1. 使用useGeneratedKeys+keyProperty (推荐) 将插入的ID赋值给设置的keyProperty对象属性字段里面，一般也就是对象的ID，比如插入User对象，设置赋值主键ID给id字段。 1&lt;insert id=\"\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; 2. 使用selectKey 也就是上述方式 # select在操作数据库当中往往查询比插入难度更加大,更加繁琐 Dao 层123456789@Repositorypublic interface CityMapper &#123; int deleteByPrimaryKey(Integer id); int insert(City record); City selectByPrimaryKey(Integer id); List&lt;City&gt; selectAll(); int updateByPrimaryKey(City record); List&lt;City&gt; getListByCriteria(@Param(\"queryObject\") City record);&#125; Mapper123456789101112&lt;select id=\"getListByCriteria\" parameterType=\"com.whatdy.model.City\" resultMap=\"BaseResultMap\"&gt; select * from city &lt;include refid=\"select_where_clause\"/&gt;&lt;/select&gt;&lt;sql id=\"select_where_clause\"&gt; &lt;trim prefixOverrides=\"AND|OR\" prefix=\"where\"&gt; &lt;if test=\"queryObject.id != null\"&gt;AND id = #&#123;queryObject.id&#125;&lt;/if&gt; &lt;if test=\"queryObject.name != null\"&gt;AND id = #&#123;queryObject.name&#125;&lt;/if&gt; &lt;if test=\"queryObject.state != null\"&gt;AND id = #&#123;queryObject.state&#125;&lt;/if&gt; &lt;if test=\"queryObject.country != null\"&gt;AND id = #&#123;queryObject.country&#125;&lt;/if&gt; &lt;/trim&gt;&lt;/sql&gt; # association , collection 关联-association 集合-collection 1234public class User&#123; private Card card_one; private List&lt;Card&gt; card_many;&#125; 在映射 card_one 属性时候用 association 标签,映射 card_many 的时候使用 collection association 用于一对一 和 多对一,collection 用于 一对多关系 例子: 123456789101112131415161718class User&#123; private List&lt;Products&gt; productsList; private Integer id; private String username; private String password; private Date createdAt; private Date updatedAt;&#125;class Products&#123; private Integer id; private String pname; private Float price; private Integer uid; private Date createdAt; private Date updatedAt; private Users users;&#125; UsersMapper.xml12345678910111213141516171819202122232425&lt;resultMap id=\"BaseProductResultMap\" type=\"com.whatdy.model.Products\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"pname\" property=\"pname\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"price\" property=\"price\" jdbcType=\"REAL\"/&gt; &lt;result column=\"uid\" property=\"uid\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"created_at\" property=\"createdAt\" jdbcType=\"DATE\"/&gt; &lt;result column=\"updated_at\" property=\"updatedAt\" jdbcType=\"DATE\"/&gt;&lt;/resultMap&gt;&lt;!-- 表关联--&gt;&lt;resultMap id=\"detailUserResultMap\" type=\"com.whatdy.model.Users\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"username\" property=\"username\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"created_at\" property=\"createdAt\" jdbcType=\"DATE\"/&gt; &lt;result column=\"updated_at\" property=\"updatedAt\" jdbcType=\"DATE\"/&gt; &lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --&gt; &lt;collection property=\"productsList\" ofType=\"com.whatdy.model.Products\" javaType=\"ArrayList\" resultMap=\"BaseProductResultMap\"&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selectUserDetails\" resultMap=\"detailUserResultMap\"&gt; SELECT * FROM users B left JOIN products A on B.id = A.uid WHERE B.id = #&#123;id&#125;&lt;/select&gt; ProductMapper.xml 123456789101112131415161718192021222324&lt;resultMap type=\"com.whatdy.model.Users\" id=\"userResult\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"username\" property=\"username\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"created_at\" property=\"createdAt\" jdbcType=\"DATE\"/&gt; &lt;result column=\"updated_at\" property=\"updatedAt\" jdbcType=\"DATE\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"userAndProductResultMap\" type=\"com.whatdy.model.Products\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"pname\" property=\"pname\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"price\" property=\"price\" jdbcType=\"REAL\"/&gt; &lt;result column=\"uid\" property=\"uid\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"created_at\" property=\"createdAt\" jdbcType=\"DATE\"/&gt; &lt;result column=\"updated_at\" property=\"updatedAt\" jdbcType=\"DATE\"/&gt; &lt;!--使用 resultMap 属性引用上面的 User 实体映射--&gt; &lt;association property=\"users\" column=\"uid\" javaType=\"com.whatdy.model.Users\" jdbcType=\"INTEGER\" resultMap=\"userResult\"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!--关联 一对一--&gt;&lt;select id=\"selectUserAndProduct\" resultMap=\"userAndProductResultMap\"&gt; select * from products A LEFT JOIN users B ON A.uid = B.id&lt;/select&gt; Dao 层123456789@Repositorypublic interface ProductsMapper &#123; List&lt;Products&gt; selectUserAndProduct();&#125;@Repositorypublic interface UsersMapper &#123; List&lt;Users&gt; selectUserDetails(Integer id);&#125; 测试 TestUserService123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class UserService &#123; protected static final Logger LOGGER = (Logger) LoggerFactory.getLogger(UserService.class); @Autowired protected UsersMapper usersMapper; @Test public void testAssociationTable() &#123; List&lt;Users&gt; usersList = usersMapper.selectUserDetails(1); for (Users u : usersList) &#123; System.out.println(u); &#125; &#125;&#125; TestProductService123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class ProductService &#123; protected static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ProductService.class); @Autowired protected ProductsMapper productsMapper; @Test public void testAssociationTable() &#123; List&lt;Products&gt; list = productsMapper.selectUserAndProduct(); System.out.println(list); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.whatdy.com/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"https://www.whatdy.com/tags/mybatis/"}]},{"title":"JAVA 日志","slug":"JAVA-日志","date":"2018-03-25T03:23:45.000Z","updated":"2018-03-25T03:26:40.000Z","comments":true,"path":"2018/03/25/JAVA-日志/","link":"","permalink":"https://www.whatdy.com/2018/03/25/JAVA-日志/","excerpt":"","text":"static Level WARNWARN level表明会出现潜在错误的情形。static Level ERRORERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。static Level FATALFATAL level指出每个严重的错误事件将会导致应用程序的退出。另外，还有两个可用的特别的日志记录级别: (以下描述来自log4j APIhttp://jakarta.apache.org/log4j/docs/api/index.html):static Level ALLALL Level是最低等级的，用于打开所有日志记录。static Level OFF OFF Level是最高等级的，用于关闭所有日志记录。日志记录器（Logger）的行为是分等级的。如下表所示：分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来，也是说大于等于的级别的日志才输出。日志记录的级别有继承性，子类会记录父类的所有的日志级别。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.whatdy.com/tags/java/"}]},{"title":"使用阿里云ECS搭建Shadowscoks和VPN翻墙","slug":"使用阿里云ECS搭建Shadowscoks和VPN翻墙","date":"2018-03-24T15:33:37.000Z","updated":"2018-03-25T03:24:44.000Z","comments":true,"path":"2018/03/24/使用阿里云ECS搭建Shadowscoks和VPN翻墙/","link":"","permalink":"https://www.whatdy.com/2018/03/24/使用阿里云ECS搭建Shadowscoks和VPN翻墙/","excerpt":"","text":"ShadowsocksX: https://github.com/shadowsocks/ShadowsocksX-NG/releases 1 为什么翻墙作为一个技术人员, 最常用的就是Google、StackOverflow、Github这些网站, 工作期间几乎每分钟都在用。 另外,偶尔也上上Facebook、YouTube、草榴以及Porn, 娱乐一下自己。 如果不能翻墙, 几乎就是鱼离开了水, 人离开了空气, 感觉一刻都不能待下去。 2 常用的翻墙方法常用的翻墙方法是: 1 购买一台大陆以外的服务器,搭建VPN或者ShadowScoks。 2 购买第三方的代理服务。 (我试用过后,觉得速度不可控,而且限制多。 况且我们公司人多, 算下来不如自己搭建划算) 3 使用自由门、GoAgent(速度比较慢、经常不能用、mac或者手机上用不了) 我用的电脑是Mac, 电脑支持VPN、ShadowSocks, 手机是iPhone, 没有越狱,不支持ShadowSocks(更正: 现在在App Store 下载 Wingy 软件,已经支持ShadowSocks)。 电脑版的ShadowSocks客户端支持自动代理模式,国内的不走代理,国外的走代理,而且能自定义。 而VPN只能完全代理。 所以我决定Shadowscoks和VPN都搭建。 电脑上主要用Shadowsocks,手机上用VPN(更正:手机上可以用 Wingy 了)。 那么,如何选择一家合适的代理服务器呢? 国外比较知名的云服务运营商有有Linode、DigitalOcean等, 费用基本10美元一个月。ping值在200左右。 国内阿里云也有香港和美国节点,香港节点价格117元/月, ping值在50左右。 之前2年用的是linode, 一直比较稳定,但是最近, 速度实在太慢了, 决定迁回阿里云香港试一下。 在这里做个记录。 (更正: 2017年之前阿里云香港的服务器是可以用的, 现在(2017年底)已经搭建的 Shadowsocks Server 貌似不受影响, 但新搭建的貌似已经不能访问了, 所以建议使用 阿里云新加坡 的机房搭建) 3 实施3.1 购买服务器在阿里云后台,购买 1核CPU 1GB内存 的服务器, 操作系统选择的是 CentOS 7.0 64位, 价格117元/月。 3.2 使用Shdowsocks翻墙1) 安装Shdowsocks服务端登录阿里云服务器, 执行以下命令12345# 安装pipyum install python-pip# 使用pip安装shadowsockspip install shadowsocks 2) 配置Shdowsocks服务,并启动新建 /etc/shadowsocks.json 文件, 并写入以下内容1234567891011&#123; \"server\":\"remote-shadowsocks-server-ip-addr\", \"server_port\":443, \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"password\":\"your-passwd\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":false, \"workers\":5&#125; 注意修改 server 和 password, workers 表示启动的进程数量。 server_port 强烈建议使用443端口, 其它端口容易被查封。 然后使用以下命令启动: ssserver -c /etc/shadowsocks.json -d start 如果出现报错: Cannot assign requested address, 请将 server 换成 0.0.0.0, 然后重新启动上面的命令。 3) 使用本机Shdowsocks客户端, 连接服务端上网如果用的是mac, 上网站 https://sourceforge.net/projects/shadowsocksgui/ 下载客户端。 安装完后进行如下配置: 如果是windows, 上面的网站也有客户端下载链接。 如果是android, 参考网站 https://github.com/shadowsocks/shadowsocks-android 如果是iPhone, 那你用不了shadowsocks, 只能用下面的VPN了。(更正,现在可以用 Wingy 了) 3.3 使用VPN翻墙VPN 隧道协议PPTP、L2TP、IPSec和SSLVPN（SSTP，OpenVPN）中安全性逐级提高，相应的受到墙的干扰逐级减弱。 考虑到跨平台，PPTP穿透力及安全性，这里搭建支持 ikev1/ikev2 的 Ipsec VPN，适用于iOS、Android、Windows 7+ 、MacOS X,及Linux。 为了兼容Windows 7以下的系统，同时搭建L2TP/IPSec支持。 TODO: 待完善 python + docker 方式搭建Ubuntu:1234curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -apt install docker.io# 映射1984 到宿主机443 端口docker run -d -p 443:1984 oddrationale/docker-shadowsocks -s 0.0.0.0 -p 1984 -k &lt;密码&gt; -m aes-256-cfb 我们就可以利用 Shadowsocks iOS/OX/windows/android 等版本进行登录了1234账号: xx.xx.xx.xx端口: 442加密方式: aes-256-cfb密码: &lt;密码&gt;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.whatdy.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.whatdy.com/tags/Linux/"}]},{"title":"openvpn 服务器搭建","slug":"openvpn-服务器搭建","date":"2018-03-24T15:31:09.000Z","updated":"2018-03-24T15:32:58.000Z","comments":true,"path":"2018/03/24/openvpn-服务器搭建/","link":"","permalink":"https://www.whatdy.com/2018/03/24/openvpn-服务器搭建/","excerpt":"","text":"服务器配置 centos7 12345678910111213141516171819202122232425262728293031323334## docker自行安装奥yum install dockerdocker pull kylemanna/openvpnOVPN_DATA=\"/data/ovpn-data\"// 下面的全局变量替换为你的服务器的外网IPIP=\"xxx.xxx.xxx.xxx\"mkdir -p $&#123;OVPN_DATA&#125;// 第二步docker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u tcp://$&#123;IP&#125;// 第三步docker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki// ---------------------------------------------------------Enter PEM pass phrase: 输入123456（你是看不见的）Verifying - Enter PEM pass phrase: 输入123456（你是看不见的）Common Name (eg: your user, host, or server name) [Easy-RSA CA]:回车一下Enter pass phrase for /etc/openvpn/pki/private/ca.key:输入123456// ---------------------------------------------------------// 第五步docker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full CLIENTNAME nopass// ---------------------------------------------------------Enter pass phrase for /etc/openvpn/pki/private/ca.key:输入123456// ---------------------------------------------------------// 第六步docker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient CLIENTNAME &gt; $&#123;OVPN_DATA&#125;/CLIENTNAME.ovpn// 第七步docker run --name openvpn -v $&#123;OVPN_DATA&#125;:/etc/openvpn -d -p 1194:1194 --privileged kylemanna/openvpn 经过以上七个步骤，你将会在/data/ovpn-data中看到一个CLIENTNAME.ovpn文件，将其下载到本地，利用OpenVPN GUI连接，即可。 经过整理后即： 1234567891011## docker自行安装奥yum install dockerdocker pull kylemanna/openvpnOVPN_DATA=\"/data/ovpn-data\"IP=\"123.123.123.123\"mkdir $&#123;OVPN_DATA&#125;docker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u tcp://$&#123;IP&#125;docker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpkidocker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full CLIENTNAME nopassdocker run -v $&#123;OVPN_DATA&#125;:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient CLIENTNAME &gt; $&#123;OVPN_DATA&#125;/CLIENTNAME.ovpndocker run --name openvpn -v $&#123;OVPN_DATA&#125;:/etc/openvpn -d -p 1194:1194 --privileged kylemanna/openvpn OPENVPN连接mac 版本下载Tunnelblick 将 *.ovpn 添加到配置,连接即可","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.whatdy.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.whatdy.com/tags/Linux/"}]},{"title":"Linux curl && http","slug":"Linux-curl-http","date":"2018-03-24T15:24:02.000Z","updated":"2018-03-25T14:33:27.000Z","comments":true,"path":"2018/03/24/Linux-curl-http/","link":"","permalink":"https://www.whatdy.com/2018/03/24/Linux-curl-http/","excerpt":"","text":"# CURL 命令常用参数列表: -A/–user-agent 设置用户代理发送给服务器-b/–cookie &lt;name=string/file&gt; cookie字符串或文件读取位置–basic 使用HTTP基本验证-c/–cookie-jar 操作结束后把cookie写入到这个文件中-d/–data HTTP POST方式传送数据-D/–dump-header 把header信息写入到该文件中-e/–referer 来源网址-G/–get 以get的方式来发送数据-H/–header 自定义头信息传递给服务器-i/–include 输出时包括protocol头信息-I/–head 只显示请求头信息-s，可以去除统计信息 -o/–output 把输出写到该文件中-u/–user &lt;user[:password]&gt; 设置服务器的用户和密码-x/–proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理-X/–request 指定什么命令 例子:1234567891011#!/bin/bash# post 带着请求头,post body并且显示protocol头信息# -H 'Content-Type:application/json' \\curl -s -i -X POST \\ -H 'Accept:application/json; text/plain, */*' \\ -H 'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_6 like Mac OS X) AppleWebKit/604.5.6 (KHTML, like Gecko) Mobile/15D100' \\ -H \"Cookie:app_name=ShenDeng\" \\ -H \"X-Requested-With: XMLHttpRequest\" \\ -H \"Origin: http://localhost\" \\ -H \"Host: http://localhost\" \\ http://localhost:8000 -d \"app_id=1325997595&amp;idfa=53B9A1CA-72F1-46E2-89C2-969120929E95&amp;ip=127.0.0.1&amp;source=hcc\" 参考: http://man.linuxde.net/curl # http 命令 Http 命令默认显示头部信息,带有高亮,JSON数据自动格式化 截取常用部分 123456789101112131415$ http example.org # =&gt; GET$ http example.org hello=world # =&gt; POST$ http :3000 # =&gt; http://localhost:3000$ http :/foo # =&gt; http://localhost/foo&apos;:&apos; HTTP headers: Referer:http://httpie.org Cookie:foo=bar User-Agent:bacon/1.0&apos;==&apos; URL parameters to be appended to the request URI: search==httpie&apos;=&apos; Data fields to be serialized into a JSON object (with --json, -j) or form data (with --form, -f): name=HTTPie language=Python description=&apos;CLI HTTP client&apos;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.whatdy.com/tags/Linux/"}]},{"title":"spring boot 发送网络请求","slug":"spring-boot-发送网络请求","date":"2018-03-24T11:08:22.000Z","updated":"2018-03-24T15:28:47.000Z","comments":true,"path":"2018/03/24/spring-boot-发送网络请求/","link":"","permalink":"https://www.whatdy.com/2018/03/24/spring-boot-发送网络请求/","excerpt":"","text":"# Spring boot RestTemplate GET 请求误区错误使用方式 1234567String url = \"http://localhost:8080/test/sendSms\";Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;();uriVariables.put(\"phone\", \"151xxxxxxxx\");uriVariables.put(\"msg\", \"测试短信内容\");String result = restOperations.getForObject(url, String.class, uriVariables); 正确使用方式123456789 String url = \"http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;msg&#125;\";HashMap&lt;String, Object&gt; uriVariables = new HashMap&lt;&gt;();uriVariables.put(\"phone\",\"153xxxxxxxx\");uriVariables.put(\"msg\",\"短息消息\");String result = restOperations.getForObject(url,String.class,uriVariables);// 等价于 String result = restOperations.getForObject(url, String.class, \"151xxxxxxxx\", \"测试短信内容\");System.out.println(result); # String Boot 使用 RestTemplate 中文乱码问题由于 StringHttpMessageConverter 默认使用的是 ISO-8859-1 编码,所以这里我们采用下面的策略修改默认编码,有的同学通过修改源码,这里不推荐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zw.utils;import org.springframework.http.*;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.util.LinkedMultiValueMap;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;import java.nio.charset.StandardCharsets;import java.util.List;/** * @author youliangzhang * @date 2018/3/24 下午6:11 **/public class HttpClient &#123; public String client(String url, HttpMethod method, MultiValueMap&lt;String, String&gt; params) &#123; // 获取对话 RestTemplate client = new RestTemplate(); this.reInitMessageConverter(client); // 请求头 HttpHeaders headers = new HttpHeaders(); // 请勿轻易改变此提交方式，大部分的情况下，提交方式都是表单提交 MediaType type = MediaType.parseMediaType(\"application/x-www-form-urlencoded; charset=UTF-8\"); headers.setContentType(type); headers.add(\"Accept\", MediaType.APPLICATION_JSON.toString()); //我们发起 HTTP 请求还是最好加上\"Connection\",\"close\" ，有利于程序的健壮性 headers.set(\"Connection\", \"close\"); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(params, headers); // 执行HTTP请求 ResponseEntity&lt;String&gt; response = client.exchange(url, method, requestEntity, String.class); return response.getBody(); &#125; /** * 初始化RestTemplate，RestTemplate会默认添加HttpMessageConverter,添加的StringHttpMessageConverter非UTF-8 * 所以先要移除原有的StringHttpMessageConverter，再添加一个字符集为UTF-8的StringHttpMessageConvert * @param restTemplate */ private void reInitMessageConverter(RestTemplate restTemplate) &#123; List&lt;HttpMessageConverter&lt;?&gt;&gt; converterList = restTemplate.getMessageConverters(); HttpMessageConverter&lt;?&gt; converterTarget = null; for (HttpMessageConverter&lt;?&gt; item : converterList) &#123; if (item.getClass() == StringHttpMessageConverter.class) &#123; converterTarget = item; break; &#125; &#125; if (converterTarget != null) &#123; converterList.remove(converterTarget); &#125; HttpMessageConverter&lt;?&gt; converter = new StringHttpMessageConverter(StandardCharsets.UTF_8); converterList.add(converter); &#125; public static void main(String[] args) &#123; HttpClient client = new HttpClient(); //String url = \"http://localhost:8000\"; String url = \"https://www.baidu.com\"; HttpMethod method = HttpMethod.POST; // 封装参数,千万不要替换为Map与HashMap,否则无法传参 MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;(); params.add(\"access_token\", \"xxxx\"); String content = client.client(url, method, params); System.out.println(content); &#125;&#125; exchange 参数列表情况:1234567restTemplate.exchange( String url, HttpMethod method, HttpEntity requestEntity, Class responseType, Object uriVariables[]) 说明：1）url: 请求地址；2）method: 请求类型(如：POST,PUT,DELETE,GET)；3）requestEntity: 请求实体，封装请求头，请求内容4）responseType: 响应类型，根据服务接口的返回类型决定5）uriVariables: url中参数变量值","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.whatdy.com/tags/java/"}]},{"title":"spring 注解","slug":"spring-注解","date":"2018-03-23T17:20:21.000Z","updated":"2018-03-23T17:23:42.000Z","comments":true,"path":"2018/03/24/spring-注解/","link":"","permalink":"https://www.whatdy.com/2018/03/24/spring-注解/","excerpt":"","text":"SpringCloud 注解# @SpringBootApplication等价于@Configuration、@EnableAutoConfiguration、@ComponentScan, 查看SpringBootApplication注解可以发现 @ComponentScan 并没有添加任何的参数，它会自动扫描工程里所有的@Component, @Service, @Repository, @Controller并把它们注册为Spring Beans。 # @AutoWired自动装载 # @Component泛指组件，一般用于普通POJO,当组件不好归类的时候，也可以使用这个注解进行标注。 # @Service用于标注业务层组件 # @RestController用于标注控制层组件。@RestController同时包含了@Controller、@ResponseBody。 # @GetMapping也是一个组合注解，相当于@RequestMapping(method = RequestMethod.GET)的缩写。 类似的还有@PostMapping、@PutMapping、@DeleteMapping。 # @PathVariable这里出现了@PathVariable，@Pathvariable注解可以绑定占位符传过来的值到方法的参数上。 # @RequestParam从请求中提取参数,如果传入参数名字和方法参数名字不一致，可以给@RequestParam的属性赋值 1234@PostMapping(value = &quot;login&quot;)public void login(@RequestParam(&quot;account&quot;) String name, @RequestParam String password) &#123; System.out.println(name + &quot;:&quot; + password);&#125; # @RequestBody可以用来解析json字符串(还可以解析xml)，并将字符串映射到对应的实体中，实体的字段名和json中的键名要对应。 1234@PostMapping(path = &quot;register&quot;)public String registerUser(@RequestBody User user) &#123; return user.toString();&#125; # @RequestHeader注解用来将请求头的内容绑定到方法参数上 1234@PostMapping(value = &quot;login&quot;)public void login(@RequestHeader(&quot;access_token&quot;) String accessToken,@RequestParam String name) &#123; System.out.println(&quot;accessToken:&quot; + accessToken);&#125; @Value 为了简化从 properties 中取配置,可以使用 @Value application.properties 12@Value(&quot;$&#123;wx_appid&#125;&quot;)private String appid; # @Valid网上一大片使用@Valid失效不能用的情况。为什么呢？ 1.@Valid必需使用在以@RequestBody接收参数的情况下。 2.使用ajax以POST方式提示数据，禁止用Fiddler以及浏览器直接访问的方式测试接口 3.用&lt;mvc:annotation-driven /&gt;添加注解驱动。 4.@Valid是应用在javabean上的校验。 全部参数校验如下： 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=)验证注解的元素值长度在min和max区间内 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 数值检查，建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为””,Integer为null @Min(value=””) 验证 Number 和 String 对象是否大等于指定的值 @Max(value=””) 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax(value=值) 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin(value=值) 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=)验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 @Range(min=, max=) 检查数字是否介于min和max之间. @Range(min=10000,max=50000,message=”range.bean.wage”) private BigDecimal wage; @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang=,script=, alias=) @URL(protocol=,host=,port=,regexp=, flags=) # @Scopesingleton：单例，即容器里只有一个实例对象。 request：对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 prototype：多对象，每一次请求都会产生一个新的bean实例 # 元注解包括 @Retention @Target @Document @Inherited@Retention: 定义注解的保留策略： @Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含 @Retention(RetentionPolicy.CLASS) //默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得， @Retention(RetentionPolicy.RUNTIME) //注解会在class字节码文件中存在，在运行时可以通过反射获取到 @Target：定义注解的作用目标: @Target(ElementType.TYPE) //接口、类、枚举、注解 @Target(ElementType.FIELD) //字段、枚举的常量 @Target(ElementType.METHOD) //方法 @Target(ElementType.PARAMETER) //方法参数 @Target(ElementType.CONSTRUCTOR) //构造函数 @Target(ElementType.LOCAL_VARIABLE)//局部变量 @Target(ElementType.ANNOTATION_TYPE)//注解 @Target(ElementType.PACKAGE) ///包 由以上的源码可以知道，他的elementType 可以有多个，一个注解可以为类的，方法的，字段的等等 @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.whatdy.com/tags/java/"}]},{"title":"阿里云支持 ipv6","slug":"阿里云支持-ipv6","date":"2018-03-20T16:29:45.000Z","updated":"2018-03-21T13:11:52.000Z","comments":true,"path":"2018/03/21/阿里云支持-ipv6/","link":"","permalink":"https://www.whatdy.com/2018/03/21/阿里云支持-ipv6/","excerpt":"","text":"# 基础 Ubuntu 16.04 tunnelbroker ipv6 隧道地址 # 步骤启用 IPv6 的主要有四步： 注册并创建 IPv6 通道 配置 ECS 使其支持 IPv6 配置 Nginx 使其监听 IPv6 端口 配置 DNS 使其支持 IPv6 解析 第一步：注册并创建 IPv6 通道 注册 https://www.tunnelbroker.net/ （需要邮箱验证） 点击 Create Regular Tunnel 在IPv4 Endpoint (Your side)处填上 ECS 的 IPv4 地址 在Available Tunnel Servers中选择Hong Kong, HK（如果你面向海外用户，可以选择更接近目标用户的地区）点击Create Tunnel后，通道就创建完成了 第二步：配置 ECS 使其支持 IPv6编辑/etc/sysctl.conf，将以下三项的配置改成0 123net.ipv6.conf.all.disable_ipv6 = 0net.ipv6.conf.default.disable_ipv6 = 0net.ipv6.conf.lo.disable_ipv6 = 0 在/etc/network/interfaces底部加上以下内容（注：下面大写的处，需要替换成你在 HE 得到的Server IPv6 Address，但不包括最后的::1/64，如：2001:470:100:100） 12345678910111213auto he-ipv6iface he-ipv6 inet6 v4tunneladdress &lt;IPV6&gt;::2netmask 64remote &lt;HE 的 Server IPv4 Address&gt;local &lt;阿里云的 IPv4 地址(Notice: 是 DHCP服务获取的IPv4地址,而不是提供给 tunnelbroker 的那个地址 )&gt;endpoint anyttl 255gateway &lt;IPv6&gt;::1up ip -6 route add 2000::/3 via ::&lt;HE 的 Server IPv4 Address&gt; dev he-ipv6up ip -6 addr add &lt;IPv6&gt;::1:1/128 dev he-ipv6up ip -6 addr add &lt;IPv6&gt;::2:1/128 dev he-ipv6down ip -6 route flush dev he-ipv6 重启服务器 12345## 检测$ ifup he-ipv6## 重启 网卡$ ifdown he-ipv6 &amp;&amp; ifup he-ipv6 # 参考https://jiandanxinli.github.io/2016-08-06.html","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://www.whatdy.com/tags/网络安全/"}]},{"title":"网络安全相关命令","slug":"网络安全相关命令","date":"2018-03-20T16:26:14.000Z","updated":"2018-03-21T13:11:52.000Z","comments":true,"path":"2018/03/21/网络安全相关命令/","link":"","permalink":"https://www.whatdy.com/2018/03/21/网络安全相关命令/","excerpt":"","text":"# mac1234## 获取全部 网络服务networksetup -listallnetworkservices## 获取 wifi 的信息networksetup -getinfo Wi-Fi # ICMPICMP (Internet Control Message Protocol) # 路由表123456789101112131415## ===&gt; mac ## 列出 route table$ netstat -nr## 只显示 IPV4 路由netstat -nr -f inet## 只显示 IPV6 路由netstat -nr -f inet6## route 操作 route table## ===&gt; linux## 列出 route,以及操作 route table$ routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault 172.16.79.253 0.0.0.0 UG 0 0 0 eth0 向路由表添加一个路由信息 一般来说，都是为了能访问别的子网才设置路由的 操作 route table12route add -net 224.0.0.0 netmask 240.0.0.0 rejectroute del -net 224.0.0.0 netmask 240.0.0.0 reject 参考: http://luodw.cc/2015/12/30/network-command/http://network.51cto.com/art/201503/469761.htm 分类:（1）链路层协议发现的路由（即是直连路由）（2）静态路由（3）动态路由协议发现的路由。 # route 命令 ARP 地址解析协议 https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E8%A1%A8 # nslookup 和 dig123456789101112131415161718192021222324252627282930313233343536$ nslookup www.baidu.comServer: 192.168.0.1Address: 192.168.0.1#53Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 115.239.211.112Name: www.a.shifen.comAddress: 115.239.210.27$ dig trace www.baidu.com;; ANSWER SECTION:www.baidu.com. 300 IN CNAME www.a.shifen.com.www.a.shifen.com. 300 IN A 115.239.210.27www.a.shifen.com. 300 IN A 115.239.211.112$ host baidu.com baidu.com has address 123.125.114.144baidu.com has address 220.181.57.216baidu.com has address 111.13.101.208baidu.com mail is handled by 15 mx.n.shifen.com.baidu.com mail is handled by 10 mx.maillb.baidu.com.baidu.com mail is handled by 20 mx1.baidu.com.baidu.com mail is handled by 20 jpmx.baidu.com.baidu.com mail is handled by 20 mx50.baidu.com.## host -a baidu.com## -a 参数,输出 和 dig baidu.com 一样详细## host -t ns baidu.com## -t 查询执行类型的记录## soa 权威域名服务器的选项## host -C baidu.com 参考: http://luodw.cc/2015/12/27/dns03/ # arp原理: http://blog.csdn.net/Linux_ever/article/details/50516502 1234567# 查看 ip 和 mac 映射arp -a# 清除 eth0 网卡的arp信息arp -d -i eth0 -a# 利用 tcpdump 观察 arp 信息 # 观察 dst,src 为 172.16.78.9 的 数据流tcpdump -i eth0 -ent '(dst 172.16.78.9 or src 172.16.78.9)' # Linux 下查看局域网内所有主机IP和MAChttp://blog.csdn.net/keepsmi1e/article/details/9370049 用 nmap 对局域网扫描一遍,然后查看 arp 缓存表就可以知道局域网内 ip 对应的 mac 了.nmap比较强大也可以直接扫描mac地址和端口。执行扫描之后就可以 cat/proc/net/arp查看arp缓存表了。 1234567891011121314# 进行 ping 扫描,打印出对扫描做出相应的主机nmap -sP 192.168.0.1/24# 仅列出指定网络上的每台主机,不发送任何报文到目标主机nmap -sL 192.168.0.1/24# 探测目标主机开放的端口，可以指定一个以逗号分隔的端口列表(如-PS22，23，25，80)nmap -PS 118.31.78.77# 使用UDPping探测主机nmap -PU 192.168.0.1/24# 使用频率最高的扫描选项（SYN扫描,又称为半开放扫描），它不打开一个完全的TCP连接，执行得很快： nmap -sS 192.168.1.0/24# 在文件ipandmaclist.txt文件中就可以查看ip对应的mac地址了。nmap -sP -PI -PT -oN ipandmaclist.txt 192.168.0.1/24 # traceroute1traceroute www.baidu.com # mac 相关命令https://www.jianshu.com/p/f4edc2632710 12345678910使用 dig 来诊断域名信息dig www.oschina.net A dig www.oschina.net MX查看谁正在登录到你的 Mac 机器w显示系统路由表netstat -r显示活动网络连接netstat -an显示网络统计netstat -s # tcpdump 抓包命令http://luodw.cc/2015/12/30/network-command/ 强大的抓包命令.当udp程序收到icmp不可达数据包时，用户程序是不会知道的，所以用tcpdump看到，因为tcpdump可以解析所有到大网络层的数据包，包括icmp，arp等等。当然还有udp,tcp。 123456789101112131415161718192021## 默认监听所有网络接口的流量$ tcpdump## 监听指定网络接口$ tcpdump -i eth0## 监听tcp$ tcpdump tcp$ tcpdump udp## 监听指定主机,可以是主机名或者iptcpdump host Charlestcpdump host 192.168.1.151## 监听端口tcpdump port 8080## 截获主机hostname发送的所有数据tcpdump -i eth0 src host hostname## 监视所有送到主机hostname的数据包tcpdump -i eth0 dst host hostname## 监视指定主机和端口的数据包如果想要获取主机 118.31.78.77 接收或发出的telnet包，使用如下命令sudo tcpdump tcp port 4000 and host 118.31.78.77对本机的udp 123 端口进行监视 123 为ntp的服务端口tcpdump udp port 123 # netstat 命令1234567891011121314151617181920212223242526272829303132# 默认情况下，netstat输出的是所有已连接的tcp,udp和unix域套接字netstat | more# 列出所有的端口（包括监听和未监听的） netstat -a# 只列出所有的tcp连接 netstat -at# 只列出所有的udp连接 netstat -au# 列出所有处于监听的连接，包括tcp,udp和unix域套接字 netstat -l# 只列出tcp监听端口 netstat -lt# 只列出udp监听端口 netstat -lu# 只列出unix域套接字监听端口 netstat -lx# 查看路由表信息 netstat -rRouting tablesInternet:Destination Gateway Flags Refs Use Netif Expiredefault 192.168.0.1 UGSc 11 0 en0# 一般有两条路由信息，一个是默认路由，即目的地地址不在本网络时，通过网络接口eth0，传到网关192.168.1.1这个也就是第一跳路由器的地址；如果目的地地址是在同一个局域网中，即与子网掩码255.255.255.0与之后=192.168.1.0，则没有网关，通过eth0广播询问即可。# 查询网络接口列表 netstat -i# 找出程序运行的端口 netstat -ap | grep ssh # ifconfig1234## 启动 eth0 网卡ifconfig eth0 up## 查看 eth0 网卡ifocnfig eth0 # ivp6http://test-ipv6.com/ 123456## 修改dnsnameserver 8.8.8.8nameserver 114.114.114.114 # 应当得到一个 AAAA 记录而不出现错误 dig aaaa aaaa.v6ns.test-ipv6.com # ufwUbuntu 16.04 防火墙 千万别手贱开启,否则 ssh 都连接不进去…vpn 遇到过.. # ndpNDP用来发现直接相连的邻居信息 1ndp -an","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.whatdy.com/tags/shell/"},{"name":"网络安全","slug":"网络安全","permalink":"https://www.whatdy.com/tags/网络安全/"}]},{"title":"brew 常用命令","slug":"brew-常用命令","date":"2018-03-20T16:01:12.000Z","updated":"2018-03-21T13:11:52.000Z","comments":true,"path":"2018/03/21/brew-常用命令/","link":"","permalink":"https://www.whatdy.com/2018/03/21/brew-常用命令/","excerpt":"","text":"作为一个使用 mac 的 developer,一定知道 brew 这个命令. # 目录结构/usr/local/Cellar brew 安装目录/usr/local/etc brew 配置目录/usr/local/bin brew 命令目录(优先级大于 /usr/bin) # 下面记录了一些常用的brew命令12345678910111213141516171819202122232425262728# 安装某个应用brew install xx# 搜索安装包brew search xxx# 安装扩展&lt;gihhub_user/repo&gt; ,可以获得更多的资源brew tap josegonzalez/php #查看安装的扩展列表brew tap #查看 php72 安装选项brew options php72#查看系统通过 brew 安装的服务brew services list #清除已卸载无用的启动配置文件brew services cleanup#也可以用上文提到的brew命令来管理php-fpmbrew services start|stop|restart php72# 更新某个包brew upgrade [ package_name ]#查看这个包的信息，从中我们可以得知有哪些选项可选。brew info [ package_name ] # 卸载对应包名字brew uninstall [ package_name ]# 列出过时的包brew outdated# 更新过时的包，不带包名就跟新所有包brew upgrade [ package_name ]# 更新 HomeBrew自身 brew update # brew caskbrew cask 用于安装 gui 界面的软件(例如 chrome) #实用工具12345678910111213# 快速查看 json 文件的结构brew cask install google-chrome# 预览markdown文档brew cask install qlmarkdown# .....brew cask install alfredbrew cask install appcleanerbrew cask install cheatsheetbrew cask install dropboxbrew cask install google-chromebrew cask install onepasswordbrew cask install sublime-textbrew cask install totalfinder # 其他12## 进入 brew 缓存目录,安装包首先会下载到当前目录,然后才会安装,所以我们可以事先现在好安装包来提高下载速度cd `brew --cache`","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.whatdy.com/categories/笔记/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://www.whatdy.com/tags/mac/"},{"name":"shell","slug":"shell","permalink":"https://www.whatdy.com/tags/shell/"}]},{"title":"hexo 基本命令","slug":"hexo 基本命令","date":"2018-03-19T16:00:43.000Z","updated":"2018-03-19T16:00:43.000Z","comments":true,"path":"2018/03/20/hexo 基本命令/","link":"","permalink":"https://www.whatdy.com/2018/03/20/hexo 基本命令/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}